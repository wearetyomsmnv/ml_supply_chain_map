<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ML Supply Chain Dependency Map</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* ── Reset & Base ── */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0e17; color: #e0e0e0; font-family: 'Inter', sans-serif; }

/* ── Layout Grid ── */
#app {
  display: grid;
  grid-template-rows: 56px 1fr 140px;
  grid-template-columns: 340px 1fr;
  grid-template-areas:
    "header header"
    "sidebar main"
    "timeline timeline";
  width: 100vw; height: 100vh;
}

/* ── Header ── */
#header {
  grid-area: header;
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 24px;
  background: linear-gradient(180deg, #0f1520 0%, #0a0e17 100%);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  z-index: 10;
}
#header h1 {
  font-size: 16px; font-weight: 600;
  background: linear-gradient(90deg, #00e5ff, #76ff03);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  letter-spacing: 0.5px;
}
.header-controls { display: flex; align-items: center; gap: 12px; }
.layer-filters { display: flex; gap: 6px; }
.layer-chip {
  font-size: 11px; padding: 3px 10px; border-radius: 12px;
  border: 1px solid; cursor: pointer; transition: all 0.2s;
  font-family: 'Inter', sans-serif; background: transparent; color: #ccc;
  opacity: 0.7;
}
.layer-chip.active { opacity: 1; }
.layer-chip:hover { opacity: 1; }

/* ── Simulation Button ── */
.sim-btn {
  font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 500;
  padding: 6px 16px; border-radius: 4px; cursor: pointer;
  border: 1px solid #ff1744; color: #ff1744; background: transparent;
  transition: all 0.25s; text-transform: uppercase; letter-spacing: 1px;
}
.sim-btn:hover { background: rgba(255,23,68,0.15); }
.sim-btn.active { background: #ff1744; color: #fff; box-shadow: 0 0 20px rgba(255,23,68,0.4); }
.sim-reset {
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  padding: 5px 12px; border-radius: 4px; cursor: pointer;
  border: 1px solid #555; color: #999; background: transparent;
  transition: all 0.2s; display: none;
}
.sim-reset:hover { border-color: #999; color: #fff; }

/* ── Sidebar ── */
#sidebar {
  grid-area: sidebar;
  background: #0d1117;
  border-right: 1px solid rgba(255,255,255,0.06);
  overflow-y: auto; padding: 16px;
  scrollbar-width: thin; scrollbar-color: #1a2030 #0d1117;
}
#sidebar::-webkit-scrollbar { width: 6px; }
#sidebar::-webkit-scrollbar-track { background: #0d1117; }
#sidebar::-webkit-scrollbar-thumb { background: #1a2030; border-radius: 3px; }

.sidebar-section-title {
  font-size: 10px; text-transform: uppercase; letter-spacing: 2px;
  color: #556; margin-bottom: 12px; font-weight: 600;
}

/* ── Stat Cards ── */
.stat-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px; }
.stat-card {
  background: #111820; border: 1px solid rgba(255,255,255,0.05);
  border-radius: 8px; padding: 12px; transition: border-color 0.2s;
}
.stat-card:hover { border-color: rgba(255,255,255,0.12); }
.stat-value {
  font-family: 'JetBrains Mono', monospace; font-size: 18px; font-weight: 600;
  margin-bottom: 4px; line-height: 1;
}
.stat-label { font-size: 10px; color: #667; line-height: 1.3; }

/* ── Node Detail Panel ── */
#node-detail { display: none; }
#node-detail.visible { display: block; }
.detail-header {
  display: flex; align-items: center; gap: 10px;
  margin-bottom: 14px; padding-bottom: 12px;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}
.detail-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.detail-name { font-size: 16px; font-weight: 600; }
.detail-layer { font-size: 11px; color: #667; }
.detail-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; font-size: 12px;
}
.detail-row-label { color: #667; }
.detail-row-value { font-family: 'JetBrains Mono', monospace; font-weight: 500; }
.risk-badge {
  display: inline-block; padding: 2px 8px; border-radius: 3px;
  font-size: 10px; font-weight: 600; text-transform: uppercase;
  font-family: 'JetBrains Mono', monospace;
}
.risk-critical { background: rgba(255,23,68,0.2); color: #ff1744; border: 1px solid rgba(255,23,68,0.3); }
.risk-high { background: rgba(255,145,0,0.2); color: #ff9100; border: 1px solid rgba(255,145,0,0.3); }
.risk-medium { background: rgba(255,234,0,0.2); color: #ffea00; border: 1px solid rgba(255,234,0,0.3); }

.detail-section-title {
  font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px;
  color: #556; margin: 14px 0 8px; font-weight: 600;
}
.blast-radius-text { font-size: 12px; color: #aaa; line-height: 1.5; margin-bottom: 8px; }
.cve-item {
  background: #111820; border: 1px solid rgba(255,255,255,0.05);
  border-radius: 6px; padding: 8px 10px; margin-bottom: 6px;
}
.cve-id { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #ff9100; font-weight: 500; }
.cve-desc { font-size: 11px; color: #889; margin-top: 2px; }
.cve-cvss {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  display: inline-block; padding: 1px 6px; border-radius: 3px; margin-top: 3px;
}
.attack-item {
  font-size: 12px; color: #aab; padding: 4px 0;
  border-bottom: 1px solid rgba(255,255,255,0.03);
}
.attack-date { font-family: 'JetBrains Mono', monospace; color: #ff1744; font-size: 10px; }
.maintainers-info {
  font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #ff9100;
}

/* ── Compromise simulation panel ── */
#compromise-panel { display: none; margin-top: 16px; }
#compromise-panel.visible { display: block; }
.compromise-stats {
  background: rgba(255,23,68,0.08); border: 1px solid rgba(255,23,68,0.2);
  border-radius: 8px; padding: 12px;
}
.compromise-stat-row {
  display: flex; justify-content: space-between; font-size: 12px; padding: 4px 0;
}
.compromise-stat-label { color: #ff8a80; }
.compromise-stat-value { font-family: 'JetBrains Mono', monospace; color: #ff1744; font-weight: 600; }

/* ── Main SVG ── */
#main {
  grid-area: main; position: relative; overflow: hidden;
  background: radial-gradient(ellipse at center, #0f1520 0%, #0a0e17 70%);
}
#main svg { width: 100%; height: 100%; }

.graph-hint {
  position: absolute; bottom: 16px; right: 16px;
  font-size: 11px; color: #334; pointer-events: none;
  font-family: 'JetBrains Mono', monospace;
}

/* ── Timeline ── */
#timeline {
  grid-area: timeline;
  background: #0d1117;
  border-top: 1px solid rgba(255,255,255,0.06);
  padding: 12px 24px; position: relative;
}
.timeline-title {
  font-size: 10px; text-transform: uppercase; letter-spacing: 2px;
  color: #445; font-weight: 600; margin-bottom: 8px;
}
.timeline-track {
  position: relative; height: 80px; margin-top: 4px;
}
.timeline-axis {
  position: absolute; bottom: 0; left: 0; right: 0; height: 1px;
  background: rgba(255,255,255,0.08);
}
.timeline-incident {
  position: absolute; cursor: pointer; transition: all 0.25s;
}
.timeline-dot {
  width: 12px; height: 12px; border-radius: 50%; border: 2px solid #ff1744;
  background: #0d1117; transition: all 0.25s; margin: 0 auto;
}
.timeline-incident:hover .timeline-dot {
  background: #ff1744; box-shadow: 0 0 12px rgba(255,23,68,0.6);
}
.timeline-incident.active .timeline-dot {
  background: #ff1744; box-shadow: 0 0 16px rgba(255,23,68,0.8);
}
.timeline-label {
  font-size: 9px; color: #667; text-align: center; margin-top: 4px;
  max-width: 140px; line-height: 1.2;
  display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
  overflow: hidden;
}
.timeline-incident.stagger-up { bottom: 40px !important; }
.timeline-connector {
  position: absolute; left: 50%; width: 1px; background: rgba(255,23,68,0.3);
  transform: translateX(-50%);
}
.timeline-date {
  font-family: 'JetBrains Mono', monospace; font-size: 9px;
  color: #445; text-align: center; margin-top: 2px;
}
.timeline-year-label {
  position: absolute; bottom: -2px;
  font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #334;
}

/* ── SVG Styles ── */
.node-group { cursor: pointer; }
.node-circle { stroke-width: 2.5; transition: opacity 0.3s; }
.node-hex { stroke-width: 2.5; transition: opacity 0.3s; }
.node-label {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  fill: #ccc; text-anchor: middle; pointer-events: none;
  transition: opacity 0.3s;
}
.link-line {
  fill: none; stroke-opacity: 0.25; transition: stroke-opacity 0.3s, stroke 0.3s;
}
.link-arrow { fill-opacity: 0.4; transition: fill-opacity 0.3s, fill 0.3s; }
.cluster-hull { stroke-width: 1; transition: opacity 0.3s; }

/* ── Dim state for hover ── */
.dimmed .node-circle, .dimmed .node-hex { opacity: 0.12; }
.dimmed .node-label { opacity: 0.08; }
.dimmed .link-line { stroke-opacity: 0.04; }
.dimmed .link-arrow { fill-opacity: 0.04; }
.highlighted .node-circle, .highlighted .node-hex { opacity: 1; }
.highlighted .node-label { opacity: 1; }

/* ── Compromise animation ── */
@keyframes compromisePulse {
  0% { filter: drop-shadow(0 0 4px rgba(255,23,68,0.3)); }
  50% { filter: drop-shadow(0 0 20px rgba(255,23,68,0.8)); }
  100% { filter: drop-shadow(0 0 4px rgba(255,23,68,0.3)); }
}
.compromised { animation: compromisePulse 1.2s ease-in-out infinite; }
.compromised .node-circle, .compromised .node-hex {
  stroke: #ff1744 !important; stroke-width: 3.5;
}
.compromise-link { stroke: #ff1744 !important; stroke-opacity: 0.7 !important; stroke-dasharray: 6 3; }
.compromise-arrow { fill: #ff1744 !important; fill-opacity: 0.8 !important; }

/* ── Incident flash ── */
@keyframes incidentFlash {
  0% { filter: drop-shadow(0 0 0 rgba(255,145,0,0)); }
  25% { filter: drop-shadow(0 0 25px rgba(255,145,0,0.9)); }
  50% { filter: drop-shadow(0 0 5px rgba(255,145,0,0.3)); }
  75% { filter: drop-shadow(0 0 25px rgba(255,145,0,0.9)); }
  100% { filter: drop-shadow(0 0 0 rgba(255,145,0,0)); }
}
.incident-flash { animation: incidentFlash 1.5s ease-in-out; }

/* ── Tooltip ── */
.graph-tooltip {
  position: absolute; pointer-events: none; background: #161c28;
  border: 1px solid rgba(255,255,255,0.1); border-radius: 6px;
  padding: 8px 12px; font-size: 12px; display: none;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 100;
  max-width: 220px;
}
.graph-tooltip .tt-name { font-weight: 600; margin-bottom: 2px; }
.graph-tooltip .tt-layer { font-size: 10px; color: #667; }
.graph-tooltip .tt-downloads {
  font-family: 'JetBrains Mono', monospace; font-size: 11px; margin-top: 4px; color: #aaa;
}
</style>
</head>
<body>
<div id="app">
  <!-- HEADER -->
  <header id="header">
    <h1>КАРТА ЗАВИСИМОСТЕЙ &middot; ML SUPPLY CHAIN</h1>
    <div class="header-controls">
      <div class="layer-filters" id="layerFilters"></div>
      <button class="sim-btn" id="simBtn" onclick="toggleSimMode()">&#x26A0; Симуляция компрометации</button>
      <button class="sim-reset" id="simReset" onclick="resetSimulation()">Сброс</button>
    </div>
  </header>

  <!-- SIDEBAR -->
  <aside id="sidebar">
    <div class="sidebar-section-title">Ключевые метрики экосистемы</div>
    <div class="stat-cards">
      <div class="stat-card">
        <div class="stat-value" style="color:#00e5ff">45.4B</div>
        <div class="stat-label">Загрузок моделей HuggingFace (всего)</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#76ff03">2.1M</div>
        <div class="stat-label">Моделей на HuggingFace Hub</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#ff1744">512K</div>
        <div class="stat-label">Вредоносных пакетов (2024)</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#ff9100">44.9%</div>
        <div class="stat-label">Pickle-моделей (небезопасная сериализация)</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#ffea00">~90%</div>
        <div class="stat-label">Инференса на NVIDIA CUDA</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#d500f9">10K+</div>
        <div class="stat-label">Компаний используют HuggingFace</div>
      </div>
    </div>

    <!-- Node detail panel -->
    <div id="node-detail">
      <div class="sidebar-section-title">Детали узла</div>
      <div class="detail-header">
        <div class="detail-dot" id="detailDot"></div>
        <div>
          <div class="detail-name" id="detailName"></div>
          <div class="detail-layer" id="detailLayer"></div>
        </div>
      </div>
      <div class="detail-row">
        <span class="detail-row-label">Уровень риска</span>
        <span class="detail-row-value" id="detailRisk"></span>
      </div>
      <div class="detail-row">
        <span class="detail-row-label">Загрузки/мес</span>
        <span class="detail-row-value" id="detailDownloads"></span>
      </div>
      <div class="detail-row">
        <span class="detail-row-label">Зависимых репо</span>
        <span class="detail-row-value" id="detailDeps"></span>
      </div>
      <div class="detail-row">
        <span class="detail-row-label">Мейнтейнеры</span>
        <span class="maintainers-info" id="detailMaintainers"></span>
      </div>
      <div class="detail-section-title">Радиус поражения</div>
      <div class="blast-radius-text" id="detailBlast"></div>
      <div class="detail-section-title" id="cveSectionTitle" style="display:none">CVE / Уязвимости</div>
      <div id="detailCVEs"></div>
      <div class="detail-section-title" id="attackSectionTitle" style="display:none">Атаки / Инциденты</div>
      <div id="detailAttacks"></div>
    </div>

    <!-- Compromise simulation results -->
    <div id="compromise-panel">
      <div class="sidebar-section-title" style="color:#ff1744">Результат симуляции</div>
      <div class="compromise-stats">
        <div class="compromise-stat-row">
          <span class="compromise-stat-label">Затронуто узлов</span>
          <span class="compromise-stat-value" id="compNodes">0</span>
        </div>
        <div class="compromise-stat-row">
          <span class="compromise-stat-label">Суммарно загрузок/мес</span>
          <span class="compromise-stat-value" id="compDownloads">0</span>
        </div>
        <div class="compromise-stat-row">
          <span class="compromise-stat-label">Глубина каскада</span>
          <span class="compromise-stat-value" id="compDepth">0</span>
        </div>
      </div>
    </div>
  </aside>

  <!-- MAIN GRAPH -->
  <div id="main">
    <svg id="graphSvg"></svg>
    <div class="graph-tooltip" id="tooltip"></div>
    <div class="graph-hint" id="graphHint">колёсико: масштаб &middot; перетаскивание: навигация &middot; клик: детали</div>
  </div>

  <!-- TIMELINE -->
  <div id="timeline">
    <div class="timeline-title">Хронология инцидентов в ML-экосистеме</div>
    <div class="timeline-track" id="timelineTrack">
      <div class="timeline-axis"></div>
    </div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════════
// DATA
// ══════════════════════════════════════════════════

const LAYERS = {
  hardware:  { name: 'Аппаратный',          color: '#ff1744', order: 0 },
  base:      { name: 'Базовые библиотеки',  color: '#ff9100', order: 1 },
  framework: { name: 'ML Фреймворки',       color: '#ffea00', order: 2 },
  hf:        { name: 'Экосистема HuggingFace', color: '#00e5ff', order: 3 },
  serving:   { name: 'Сервинг',             color: '#76ff03', order: 4 },
  app:       { name: 'Приложения',          color: '#d500f9', order: 5 },
};

const NODES = [
  // Hardware
  { id: 'cuda',         label: 'NVIDIA CUDA',     layer: 'hardware',  downloads: 0,      risk: 95, depRepos: 0,     maintainers: 'NVIDIA Corp',
    blast: 'Компрометация CUDA затрагивает ~90% всего GPU-инференса. PyTorch поставляет 13 CUDA-библиотек как прямые зависимости. ChatGPT, Tesla Autopilot, все production transformer-системы работают на CUDA.',
    cves: [{ id: 'CVE-2023-4969', cvss: 6.5, desc: 'LeftoverLocals — утечка памяти GPU между процессами (Apple/AMD/Qualcomm)' }],
    attacks: [], shape: 'hex' },
  { id: 'tsmc',         label: 'TSMC',             layer: 'hardware',  downloads: 0,      risk: 90, depRepos: 0,     maintainers: 'TSMC',
    blast: 'TSMC производит ~90% передовых чипов, включая все GPU NVIDIA. Геополитические риски Тайваньского пролива — экзистенциальная угроза для всей цепочки поставок AI-чипов.',
    cves: [], attacks: [], shape: 'hex' },
  { id: 'asml',         label: 'ASML',             layer: 'hardware',  downloads: 0,      risk: 85, depRepos: 0,     maintainers: 'ASML',
    blast: '100% монополия на EUV-литографию. Машины стоимостью €200M — буквально нет альтернативного поставщика для передового чипового производства.',
    cves: [], attacks: [], shape: 'hex' },
  // Base libraries
  { id: 'numpy',        label: 'numpy',            layer: 'base',      downloads: 500000000,  risk: 88, depRepos: 59200, maintainers: '~15 core',
    blast: 'Краеугольный камень ML-экосистемы. 59,200+ зависимых репо — крупнейший радиус поражения среди всех пакетов. numpy 2.0 API-breaking changes вызвали каскадные поломки по всей экосистеме.',
    cves: [], attacks: [{ date: '2023', desc: 'numpy 2.0 breaking changes — каскад поломок зависимых пакетов' }], shape: 'circle' },
  { id: 'scipy',        label: 'scipy',            layer: 'base',      downloads: 284000000,  risk: 55, depRepos: 12000, maintainers: '~10 core',
    blast: '284M загрузок/мес. Используется для научных вычислений, оптимизации, статистики в ML-пайплайнах.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'pandas',       label: 'pandas',           layer: 'base',      downloads: 437000000,  risk: 50, depRepos: 25000, maintainers: '~15 core',
    blast: '437M загрузок/мес. Слой обработки данных для большинства ML-систем.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'scikit-learn', label: 'scikit-learn',     layer: 'base',      downloads: 159000000,  risk: 55, depRepos: 18000, maintainers: '~20 core',
    blast: '159M загрузок/мес. Классический ML — классификация, регрессия, кластеризация. Зависит от numpy и scipy.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'pillow',       label: 'Pillow',           layer: 'base',      downloads: 120000000,  risk: 45, depRepos: 15000, maintainers: '~5 core',
    blast: '120M загрузок/мес. Обработка изображений, критичен для всех CV-пайплайнов.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'matplotlib',   label: 'matplotlib',       layer: 'base',      downloads: 200000000,  risk: 40, depRepos: 20000, maintainers: '~15 core',
    blast: '200M загрузок/мес. Визуализация данных, зависит от numpy. Используется повсеместно в ML-экосистеме.',
    cves: [], attacks: [], shape: 'circle' },
  // ML Frameworks
  { id: 'pytorch',      label: 'PyTorch',          layer: 'framework', downloads: 70800000,   risk: 92, depRepos: 30000, maintainers: '7 core',
    blast: '70.8M загрузок/мес. Всего 7 core-мейнтейнеров — критическая концентрация. Поставляет 13 NVIDIA CUDA-библиотек. Основной фреймворк для LLM-тренировки и инференса.',
    cves: [{ id: 'CVE-2025-32434', cvss: 9.3, desc: 'Обход weights_only=True в torch.load() — RCE через "безопасную" загрузку моделей' }],
    attacks: [{ date: '2022-12', desc: 'torchtriton dependency confusion — эксфильтрация SSH-ключей через DNS tunneling' }], shape: 'circle' },
  { id: 'tensorflow',   label: 'TensorFlow',       layer: 'framework', downloads: 21200000,   risk: 65, depRepos: 15000, maintainers: 'Google team',
    blast: '21.2M загрузок/мес. Широко используется в production-системах и на мобильных устройствах (TFLite).',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'keras',         label: 'Keras',            layer: 'framework', downloads: 30000000,   risk: 55, depRepos: 10000, maintainers: 'Google/community',
    blast: '30M загрузок/мес. Высокоуровневый API для TensorFlow и PyTorch. Широко используется для прототипирования и обучения моделей.',
    cves: [], attacks: [], shape: 'circle' },
  // HuggingFace ecosystem
  { id: 'transformers', label: 'transformers',     layer: 'hf',        downloads: 104500000,  risk: 85, depRepos: 28575, maintainers: 'HF team (~20)',
    blast: '104.5M загрузок/мес. Hub-пакет HF-экосистемы — все модели проходят через него. 28,575 GitHub-репо переиспользуют pretrained-модели.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'hf-hub',       label: 'huggingface-hub',  layer: 'hf',        downloads: 113500000,  risk: 90, depRepos: 20000, maintainers: 'HF team (~10)',
    blast: '113.5M загрузок/мес. Компрометация затронет КАЖДЫЙ пакет HF-кластера одновременно. Через него проходят 45.4B совокупных загрузок моделей.',
    cves: [],
    attacks: [{ date: '2024-02', desc: 'Namespace hijacking (AIJacking) — перехват удалённых аккаунтов, reverse shell через модели с 100K+ загрузок' }], shape: 'circle' },
  { id: 'tokenizers',   label: 'tokenizers',       layer: 'hf',        downloads: 78000000,   risk: 60, depRepos: 5000,  maintainers: 'HF team (~5)',
    blast: '78M загрузок/мес. Rust-реализация токенизации. Критичен для всех NLP-моделей.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'safetensors',  label: 'safetensors',      layer: 'hf',        downloads: 47900000,   risk: 70, depRepos: 8000,  maintainers: 'HF team (~3)',
    blast: '47.9M загрузок/мес. Позиционируется как безопасная замена pickle. Core — ~400 строк Rust. Несмотря на это, 44.9% моделей всё ещё используют pickle.',
    cves: [],
    attacks: [{ date: '2024-02', desc: 'Safetensors conversion service hijack — бот-конвертер использован для отравления моделей' }], shape: 'circle' },
  { id: 'datasets',     label: 'datasets',         layer: 'hf',        downloads: 46000000,   risk: 65, depRepos: 4000,  maintainers: 'HF team (~8)',
    blast: '46M загрузок/мес. Через него загружаются 500K+ датасетов. Найдено 9 вредоносных скриптов загрузки данных.',
    cves: [], attacks: [{ date: '2024', desc: '9 вредоносных dataset loading-скриптов обнаружены MalHug' }], shape: 'circle' },
  { id: 'accelerate',   label: 'accelerate',       layer: 'hf',        downloads: 20600000,   risk: 55, depRepos: 3000,  maintainers: 'HF team (~5)',
    blast: '20.6M загрузок/мес. Распределённая тренировка — компрометация может затронуть все тренировочные пайплайны.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'diffusers',    label: 'diffusers',        layer: 'hf',        downloads: 9800000,    risk: 55, depRepos: 2000,  maintainers: 'HF team (~8)',
    blast: '9.8M загрузок/мес. Фреймворк для диффузионных моделей (Stable Diffusion и т.д.).',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'peft',         label: 'peft',             layer: 'hf',        downloads: 7900000,    risk: 50, depRepos: 1500,  maintainers: 'HF team (~5)',
    blast: '7.9M загрузок/мес. Parameter-efficient fine-tuning — LoRA и другие адаптеры.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'trl',          label: 'trl',              layer: 'hf',        downloads: 5000000,    risk: 50, depRepos: 800,   maintainers: 'HF team (~5)',
    blast: '5M загрузок/мес. RLHF-тренировка моделей. Часть HF-кластера, зависит от transformers, pytorch, peft, accelerate, datasets.',
    cves: [], attacks: [], shape: 'circle' },
  // Serving
  { id: 'vllm',         label: 'vLLM',             layer: 'serving',   downloads: 6500000,    risk: 92, depRepos: 2000,  maintainers: '~15 core',
    blast: '5-8M загрузок/мес. Стандарт production LLM-сервинга. 60+ прямых зависимостей → ~150+ уникальных пакетов после транзитивного разрешения.',
    cves: [
      { id: 'CVE-2025-32444', cvss: 10.0, desc: 'RCE через pickle-десериализацию в Mooncake-интеграции (ZeroMQ)' },
      { id: 'CVE-2026-22778', cvss: 9.8, desc: 'RCE через обработку видео — heap overflow в FFmpeg/OpenCV' },
      { id: 'CVE-2026-22807', cvss: 8.8, desc: 'RCE через auto_map загрузку динамических модулей HF' },
      { id: 'CVE-2026-24779', cvss: 7.1, desc: 'SSRF в MediaConnector — обход валидации hostname' }
    ],
    attacks: [
      { date: '2025-04', desc: 'CVE-2025-32444 CVSS 10.0 — pickle RCE через Mooncake ZeroMQ, неавторизованный доступ' }
    ], shape: 'circle' },
  { id: 'onnx',         label: 'ONNX Runtime',     layer: 'serving',   downloads: 22900000,   risk: 60, depRepos: 5000,  maintainers: 'Microsoft',
    blast: '22.9M загрузок/мес. Кроссплатформенный инференс — используется Azure, Windows ML, многими edge-устройствами.',
    cves: [], attacks: [], shape: 'circle' },
  { id: 'triton',       label: 'Triton',           layer: 'serving',   downloads: 35700000,   risk: 75, depRepos: 3000,  maintainers: 'OpenAI/NVIDIA',
    blast: '35.7M загрузок/мес. GPU-компилятор, автозависимость PyTorch. Именно torchtriton стал целью dependency confusion атаки 2022.',
    cves: [],
    attacks: [{ date: '2022-12', desc: 'torchtriton dependency confusion — 2,717 загрузок вредоносного пакета за сутки' }], shape: 'circle' },
  // Applications
  { id: 'langchain',    label: 'LangChain',        layer: 'app',       downloads: 187000000,  risk: 75, depRepos: 8000,  maintainers: 'LangChain Inc',
    blast: '187M загрузок/мес. Фреймворк LLM-приложений — связывает все слои экосистемы в production-системах.',
    cves: [
      { id: 'CVE-2025-68664', cvss: 9.3, desc: '«LangGrinch» — injection через сериализацию, утечка секретов и RCE' },
      { id: 'CVE-2025-68665', cvss: 8.6, desc: 'То же для JS-версии @langchain/core' }
    ],
    attacks: [
      { date: '2025-12', desc: 'LangGrinch CVE-2025-68664 — утечка API-ключей и RCE через serialization injection' }
    ], shape: 'circle' },
  // New nodes from AI-Infra-Guard v3.6.2
  { id: 'ollama',       label: 'Ollama',           layer: 'serving',   downloads: 5000000,    risk: 85, depRepos: 3000,  maintainers: 'Ollama Inc (~10)',
    blast: '175K публичных серверов. RCE через OOB-write в GGUF, отсутствие аутентификации. Локальный инференс LLM.',
    cves: [
      { id: 'CVE-2025-63389', cvss: 8.5, desc: 'Отсутствие аутентификации API — несанкционированные операции с моделями' }
    ], attacks: [], shape: 'circle' },
  { id: 'mlflow',       label: 'MLflow',           layer: 'serving',   downloads: 20000000,   risk: 78, depRepos: 5000,  maintainers: 'LF AI (~20)',
    blast: '20M загрузок/мес. ML-lifecycle, model registry. Directory traversal → RCE (CVE-2025-11201).',
    cves: [
      { id: 'CVE-2025-11201', cvss: 8.8, desc: 'Directory traversal в Tracking Server → удалённое выполнение кода' }
    ], attacks: [], shape: 'circle' },
  { id: 'jupyter',      label: 'Jupyter',          layer: 'base',      downloads: 30000000,   risk: 65, depRepos: 40000, maintainers: 'Jupyter team (~30)',
    blast: '30M загрузок/мес. Основная IDE для ML. DOM clobbering через вредоносные ноутбуки (CVE-2024-43805).',
    cves: [
      { id: 'CVE-2024-43805', cvss: 7.6, desc: 'DOM Clobbering через вредоносные Markdown-ячейки в ноутбуках' }
    ], attacks: [], shape: 'circle' },
  { id: 'dask',         label: 'Dask',             layer: 'base',      downloads: 30000000,   risk: 70, depRepos: 8000,  maintainers: 'Dask team (~15)',
    blast: '30M загрузок/мес. Распределённые вычисления. Pickle-десериализация → RCE (CVE-2024-10096).',
    cves: [
      { id: 'CVE-2024-10096', cvss: 8.0, desc: 'Pickle-десериализация в distributed server → удалённое выполнение команд' }
    ], attacks: [], shape: 'circle' },
  { id: 'langflow',     label: 'Langflow',         layer: 'app',       downloads: 2000000,    risk: 82, depRepos: 1500,  maintainers: 'DataStax (~15)',
    blast: '2M загрузок/мес. 9 CVE, включая множественные RCE и code injection. Визуальный конструктор LLM-приложений.',
    cves: [
      { id: 'CVE-2025-3248', cvss: 9.8, desc: 'Неаутентифицированный RCE через /api/v1/validate/code — выполнение произвольного Python-кода' }
    ], attacks: [], shape: 'circle' },
  { id: 'dify',         label: 'Dify',             layer: 'app',       downloads: 3000000,    risk: 80, depRepos: 2000,  maintainers: 'Dify Inc (~20)',
    blast: '3M загрузок/мес. Sandbox escape с root-правами (CVE-2025-3466, CVSS 9.8). LLM-платформа.',
    cves: [
      { id: 'CVE-2025-3466', cvss: 9.8, desc: 'Sandbox escape — выполнение кода с root-правами через code node' }
    ], attacks: [], shape: 'circle' },
];

// Edges: source DEPENDS ON target (arrow from source → target)
const EDGES = [
  // Everything → numpy
  { source: 'scipy',        target: 'numpy' },
  { source: 'pandas',       target: 'numpy' },
  { source: 'pytorch',      target: 'numpy' },
  { source: 'tensorflow',   target: 'numpy' },
  { source: 'transformers', target: 'numpy' },
  { source: 'datasets',     target: 'numpy' },
  { source: 'onnx',         target: 'numpy' },
  { source: 'vllm',         target: 'numpy' },
  { source: 'accelerate',   target: 'numpy' },
  // Frameworks → CUDA
  { source: 'pytorch',      target: 'cuda' },
  { source: 'tensorflow',   target: 'cuda' },
  // HF cluster → hf-hub + pytorch
  { source: 'transformers', target: 'hf-hub' },
  { source: 'transformers', target: 'pytorch' },
  { source: 'transformers', target: 'tokenizers' },
  { source: 'transformers', target: 'safetensors' },
  { source: 'tokenizers',   target: 'hf-hub' },
  { source: 'safetensors',  target: 'hf-hub' },
  { source: 'datasets',     target: 'hf-hub' },
  { source: 'accelerate',   target: 'pytorch' },
  { source: 'accelerate',   target: 'hf-hub' },
  { source: 'diffusers',    target: 'transformers' },
  { source: 'diffusers',    target: 'pytorch' },
  { source: 'diffusers',    target: 'hf-hub' },
  { source: 'diffusers',    target: 'safetensors' },
  { source: 'diffusers',    target: 'accelerate' },
  { source: 'peft',         target: 'transformers' },
  { source: 'peft',         target: 'pytorch' },
  { source: 'peft',         target: 'hf-hub' },
  { source: 'peft',         target: 'accelerate' },
  // vLLM
  { source: 'vllm',         target: 'pytorch' },
  { source: 'vllm',         target: 'transformers' },
  { source: 'vllm',         target: 'triton' },
  // Triton → pytorch (bundled)
  { source: 'triton',       target: 'cuda' },
  // ONNX
  { source: 'onnx',         target: 'pytorch' },
  // Hardware chain
  { source: 'cuda',         target: 'tsmc' },
  { source: 'tsmc',         target: 'asml' },
  // LangChain
  { source: 'langchain',    target: 'transformers' },
  { source: 'langchain',    target: 'pytorch' },
  { source: 'langchain',    target: 'hf-hub' },
  // scipy → pandas
  { source: 'pandas',       target: 'scipy' },
  // scikit-learn
  { source: 'scikit-learn', target: 'numpy' },
  { source: 'scikit-learn', target: 'scipy' },
  // keras
  { source: 'keras',        target: 'tensorflow' },
  { source: 'keras',        target: 'numpy' },
  // pillow
  { source: 'pillow',       target: 'numpy' },
  // matplotlib
  { source: 'matplotlib',   target: 'numpy' },
  // trl
  { source: 'trl',          target: 'transformers' },
  { source: 'trl',          target: 'pytorch' },
  { source: 'trl',          target: 'hf-hub' },
  { source: 'trl',          target: 'peft' },
  { source: 'trl',          target: 'accelerate' },
  { source: 'trl',          target: 'datasets' },
  // Ollama
  { source: 'ollama',       target: 'cuda' },
  { source: 'ollama',       target: 'pytorch' },
  // MLflow
  { source: 'mlflow',       target: 'pytorch' },
  { source: 'mlflow',       target: 'tensorflow' },
  { source: 'mlflow',       target: 'numpy' },
  { source: 'mlflow',       target: 'hf-hub' },
  // Jupyter
  { source: 'jupyter',      target: 'numpy' },
  { source: 'jupyter',      target: 'scipy' },
  { source: 'jupyter',      target: 'pandas' },
  { source: 'jupyter',      target: 'matplotlib' },
  // Dask
  { source: 'dask',         target: 'numpy' },
  { source: 'dask',         target: 'scipy' },
  { source: 'dask',         target: 'pandas' },
  // Langflow
  { source: 'langflow',     target: 'langchain' },
  { source: 'langflow',     target: 'transformers' },
  { source: 'langflow',     target: 'hf-hub' },
  // Dify
  { source: 'dify',         target: 'langchain' },
  { source: 'dify',         target: 'transformers' },
  { source: 'dify',         target: 'hf-hub' },
];

const INCIDENTS = [
  { id: 'inc1', date: '2022-12', label: 'PyTorch torchtriton dependency confusion', nodes: ['pytorch', 'triton'],
    desc: 'Атакующий зарегистрировал malicious torchtriton на PyPI. 2,717 загрузок, эксфильтрация SSH-ключей через DNS tunneling.' },
  { id: 'inc2', date: '2024-02', label: '100 вредоносных моделей на HF', nodes: ['hf-hub', 'transformers'],
    desc: 'JFrog обнаружил ~100 моделей с reverse shell payload через pickle __reduce__. После удаления — повторные загрузки с новыми IP.' },
  { id: 'inc3', date: '2024-02', label: 'Safetensors конвертер hijack', nodes: ['safetensors', 'hf-hub'],
    desc: 'HiddenLayer: официальный HF conversion bot мог быть hijack\'нут для отправки malicious PR в любой репозиторий платформы.' },
  { id: 'inc4', date: '2025-02', label: 'nullifAI обход Picklescan', nodes: ['hf-hub', 'transformers', 'safetensors'],
    desc: 'ReversingLabs: 7z вместо ZIP для обхода сканера. Payload выполнялся до ошибки парсера. Кроссплатформенные reverse shells.' },
  { id: 'inc5', date: '2025-04', label: 'CVE-2025-32434 CVSS 9.3', nodes: ['pytorch'],
    desc: 'Обход weights_only=True в torch.load() — RCE через "безопасную" загрузку. Затронуты все версии PyTorch ≤2.5.1.' },
  { id: 'inc6', date: '2025-04', label: 'vLLM Mooncake RCE CVSS 10.0', nodes: ['vllm'],
    desc: 'CVE-2025-32444: pickle-десериализация через ZeroMQ в Mooncake-интеграции. CVSS 10.0, неавторизованный RCE.' },
  { id: 'inc7', date: '2025-12', label: 'LangGrinch — утечка секретов', nodes: ['langchain'],
    desc: 'CVE-2025-68664: serialization injection в langchain-core. Утечка API-ключей через prompt injection + RCE.' },
  { id: 'inc8', date: '2026-01', label: 'Ni8mare: n8n unauth RCE', nodes: ['langflow', 'dify'],
    desc: 'CVE-2026-21858 CVSS 10.0: неаутентифицированный RCE в n8n. 100K+ серверов уязвимы. Волна атак на AI-workflow платформы.' },
];

// ══════════════════════════════════════════════════
// GLOBALS
// ══════════════════════════════════════════════════
let simulation, svg, g, linkGroup, nodeGroup, hullGroup, arrowDefs;
let simMode = false;
let activeFilters = new Set(Object.keys(LAYERS));
let nodeMap = {};
let adjForward = {};  // source → [target]  (source depends on target)
let adjReverse = {};  // target → [source]  (who depends on target)

NODES.forEach(n => { nodeMap[n.id] = n; adjForward[n.id] = []; adjReverse[n.id] = []; });
EDGES.forEach(e => {
  adjForward[e.source] = adjForward[e.source] || [];
  adjForward[e.source].push(e.target);
  adjReverse[e.target] = adjReverse[e.target] || [];
  adjReverse[e.target].push(e.source);
});

// ══════════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════════
document.addEventListener('DOMContentLoaded', () => {
  buildLayerFilters();
  buildTimeline();
  buildGraph();
});

// ══════════════════════════════════════════════════
// LAYER FILTERS
// ══════════════════════════════════════════════════
function buildLayerFilters() {
  const container = document.getElementById('layerFilters');
  Object.entries(LAYERS).forEach(([key, l]) => {
    const chip = document.createElement('button');
    chip.className = 'layer-chip active';
    chip.textContent = l.name;
    chip.style.borderColor = l.color;
    chip.style.color = l.color;
    chip.dataset.layer = key;
    chip.onclick = () => toggleLayer(key, chip);
    container.appendChild(chip);
  });
}

function toggleLayer(key, chip) {
  if (activeFilters.has(key)) { activeFilters.delete(key); chip.classList.remove('active'); }
  else { activeFilters.add(key); chip.classList.add('active'); }
  updateVisibility();
}

function updateVisibility() {
  nodeGroup.each(function(d) {
    d3.select(this).style('display', activeFilters.has(d.layer) ? null : 'none');
  });
  linkGroup.each(function(d) {
    const srcVis = activeFilters.has(nodeMap[d.source.id || d.source]?.layer);
    const tgtVis = activeFilters.has(nodeMap[d.target.id || d.target]?.layer);
    d3.select(this).style('display', srcVis && tgtVis ? null : 'none');
  });
  hullGroup.each(function(d) {
    d3.select(this).style('display', activeFilters.has(d) ? null : 'none');
  });
}

// ══════════════════════════════════════════════════
// GRAPH
// ══════════════════════════════════════════════════
function buildGraph() {
  const container = document.getElementById('main');
  const W = container.clientWidth;
  const H = container.clientHeight;

  svg = d3.select('#graphSvg');

  // Defs: glow filters + arrow markers
  const defs = svg.append('defs');

  // Glow filters per layer
  Object.entries(LAYERS).forEach(([key, l]) => {
    const filter = defs.append('filter').attr('id', `glow-${key}`)
      .attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
    filter.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'blur');
    const merge = filter.append('feMerge');
    merge.append('feMergeNode').attr('in', 'blur');
    merge.append('feMergeNode').attr('in', 'SourceGraphic');
  });

  // Critical glow (stronger)
  const critGlow = defs.append('filter').attr('id', 'glow-critical')
    .attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
  critGlow.append('feGaussianBlur').attr('stdDeviation', '8').attr('result', 'blur');
  const critMerge = critGlow.append('feMerge');
  critMerge.append('feMergeNode').attr('in', 'blur');
  critMerge.append('feMergeNode').attr('in', 'SourceGraphic');

  // Arrow marker
  defs.append('marker')
    .attr('id', 'arrowhead')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 20).attr('refY', 0)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,-4L10,0L0,4').attr('class', 'link-arrow')
    .style('fill', '#556');

  // Zoom
  const zoom = d3.zoom()
    .scaleExtent([0.3, 4])
    .on('zoom', (event) => { g.attr('transform', event.transform); });
  svg.call(zoom);

  g = svg.append('g');

  // Cluster centers
  const layerCenters = {
    hardware:  { x: W * 0.15, y: H * 0.25 },
    base:      { x: W * 0.32, y: H * 0.82 },
    framework: { x: W * 0.3,  y: H * 0.5 },
    hf:        { x: W * 0.6,  y: H * 0.45 },
    serving:   { x: W * 0.82, y: H * 0.3 },
    app:       { x: W * 0.88, y: H * 0.72 },
  };

  // Radius scale
  const maxDl = d3.max(NODES, d => d.downloads);
  const rScale = d3.scaleSqrt().domain([0, maxDl]).range([14, 55]);

  // Copy nodes data
  const nodesData = NODES.map(d => ({
    ...d,
    r: d.downloads > 0 ? rScale(d.downloads) : (d.layer === 'hardware' ? 30 : 18),
    x: layerCenters[d.layer].x + (Math.random() - 0.5) * 80,
    y: layerCenters[d.layer].y + (Math.random() - 0.5) * 60,
  }));

  const edgesData = EDGES.map(d => ({ ...d }));

  // Convex hulls
  hullGroup = g.selectAll('.cluster-hull')
    .data(Object.keys(LAYERS))
    .enter().append('path')
    .attr('class', 'cluster-hull')
    .attr('fill', d => LAYERS[d].color)
    .attr('fill-opacity', 0.03)
    .attr('stroke', d => LAYERS[d].color)
    .attr('stroke-opacity', 0.12)
    .attr('stroke-dasharray', '4 2');

  // Links
  linkGroup = g.selectAll('.link-line')
    .data(edgesData)
    .enter().append('path')
    .attr('class', 'link-line')
    .attr('stroke', '#334')
    .attr('stroke-width', 1.2)
    .attr('marker-end', 'url(#arrowhead)');

  // Nodes
  nodeGroup = g.selectAll('.node-group')
    .data(nodesData)
    .enter().append('g')
    .attr('class', 'node-group')
    .call(d3.drag()
      .on('start', dragStart)
      .on('drag', dragging)
      .on('end', dragEnd))
    .on('mouseover', onNodeHover)
    .on('mouseout', onNodeOut)
    .on('click', onNodeClick);

  // Draw shapes
  nodeGroup.each(function(d) {
    const el = d3.select(this);
    const layerColor = LAYERS[d.layer].color;
    const glowFilter = d.risk >= 85 ? 'url(#glow-critical)' : `url(#glow-${d.layer})`;

    if (d.shape === 'hex') {
      const r = d.r;
      const hex = d3.range(6).map(i => {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        return [r * Math.cos(angle), r * Math.sin(angle)];
      });
      el.append('polygon')
        .attr('class', 'node-hex')
        .attr('points', hex.map(p => p.join(',')).join(' '))
        .attr('fill', hexToRGBA(layerColor, 0.15))
        .attr('stroke', layerColor)
        .style('filter', glowFilter);
    } else {
      el.append('circle')
        .attr('class', 'node-circle')
        .attr('r', d.r)
        .attr('fill', hexToRGBA(layerColor, 0.12))
        .attr('stroke', layerColor)
        .style('filter', glowFilter);
    }

    el.append('text')
      .attr('class', 'node-label')
      .attr('dy', d.r + 14)
      .text(d.label);
  });

  // Force simulation
  simulation = d3.forceSimulation(nodesData)
    .force('link', d3.forceLink(edgesData).id(d => d.id).distance(120).strength(0.3))
    .force('charge', d3.forceManyBody().strength(-400))
    .force('x', d3.forceX(d => layerCenters[d.layer].x).strength(0.15))
    .force('y', d3.forceY(d => layerCenters[d.layer].y).strength(0.15))
    .force('collide', d3.forceCollide(d => d.r + 12).strength(0.8))
    .on('tick', ticked);

  function ticked() {
    linkGroup.attr('d', d => {
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
      return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });

    nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);
    updateHulls(nodesData);
  }

  function updateHulls(nodes) {
    hullGroup.attr('d', layer => {
      const pts = nodes.filter(n => n.layer === layer).map(n => [n.x, n.y]);
      if (pts.length < 3) return null;
      const hull = d3.polygonHull(expandPoints(pts, 30));
      return hull ? `M${hull.join('L')}Z` : null;
    });
  }

  // Center view
  const initTransform = d3.zoomIdentity.translate(0, 0).scale(1);
  svg.call(zoom.transform, initTransform);

  // Resize handler
  window.addEventListener('resize', () => {
    const nW = container.clientWidth;
    const nH = container.clientHeight;
    const scaleX = nW / W;
    const scaleY = nH / H;
    Object.keys(layerCenters).forEach(k => {
      layerCenters[k].x *= scaleX;
      layerCenters[k].y *= scaleY;
    });
    simulation.force('x', d3.forceX(d => layerCenters[d.layer].x).strength(0.15));
    simulation.force('y', d3.forceY(d => layerCenters[d.layer].y).strength(0.15));
    simulation.alpha(0.3).restart();
  });
}

// ── Helpers ──
function hexToRGBA(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function expandPoints(points, padding) {
  if (points.length < 2) return points;
  const cx = d3.mean(points, p => p[0]);
  const cy = d3.mean(points, p => p[1]);
  return points.map(p => {
    const dx = p[0] - cx;
    const dy = p[1] - cy;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    return [p[0] + (dx / dist) * padding, p[1] + (dy / dist) * padding];
  });
}

function formatNumber(n) {
  if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toString();
}

// ── Drag ──
function dragStart(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragging(event, d) { d.fx = event.x; d.fy = event.y; }
function dragEnd(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// ══════════════════════════════════════════════════
// HOVER — highlight neighbors
// ══════════════════════════════════════════════════
function onNodeHover(event, d) {
  if (simMode) return;

  const neighbors = new Set([d.id]);
  (adjForward[d.id] || []).forEach(n => neighbors.add(n));
  (adjReverse[d.id] || []).forEach(n => neighbors.add(n));

  nodeGroup.classed('dimmed', n => !neighbors.has(n.id));
  nodeGroup.classed('highlighted', n => neighbors.has(n.id));
  linkGroup.classed('dimmed', e => {
    const sid = e.source.id || e.source;
    const tid = e.target.id || e.target;
    return !(sid === d.id || tid === d.id);
  });

  // Tooltip
  const tooltip = document.getElementById('tooltip');
  const mainRect = document.getElementById('main').getBoundingClientRect();
  tooltip.innerHTML = `
    <div class="tt-name" style="color:${LAYERS[d.layer].color}">${d.label}</div>
    <div class="tt-layer">${LAYERS[d.layer].name}</div>
    ${d.downloads > 0 ? `<div class="tt-downloads">${formatNumber(d.downloads)} загрузок/мес</div>` : ''}
  `;
  tooltip.style.display = 'block';
  tooltip.style.left = (event.clientX - mainRect.left + 15) + 'px';
  tooltip.style.top = (event.clientY - mainRect.top + 15) + 'px';
}

function onNodeOut(event, d) {
  if (simMode) return;
  nodeGroup.classed('dimmed', false).classed('highlighted', false);
  linkGroup.classed('dimmed', false);
  document.getElementById('tooltip').style.display = 'none';
}

// ══════════════════════════════════════════════════
// CLICK — detail panel or compromise
// ══════════════════════════════════════════════════
function onNodeClick(event, d) {
  event.stopPropagation();
  document.getElementById('tooltip').style.display = 'none';

  if (simMode) {
    runCompromiseSimulation(d);
    return;
  }

  showNodeDetail(d);
}

function showNodeDetail(d) {
  const panel = document.getElementById('node-detail');
  panel.classList.add('visible');

  document.getElementById('detailDot').style.background = LAYERS[d.layer].color;
  document.getElementById('detailName').textContent = d.label;
  document.getElementById('detailName').style.color = LAYERS[d.layer].color;
  document.getElementById('detailLayer').textContent = LAYERS[d.layer].name;

  // Risk
  const riskEl = document.getElementById('detailRisk');
  const riskClass = d.risk >= 85 ? 'risk-critical' : d.risk >= 65 ? 'risk-high' : 'risk-medium';
  const riskLabel = d.risk >= 85 ? 'КРИТИЧЕСКИЙ' : d.risk >= 65 ? 'ВЫСОКИЙ' : 'СРЕДНИЙ';
  riskEl.innerHTML = `<span class="risk-badge ${riskClass}">${d.risk}/100 ${riskLabel}</span>`;

  document.getElementById('detailDownloads').textContent = d.downloads > 0 ? formatNumber(d.downloads) : 'Н/Д (аппаратный)';
  document.getElementById('detailDeps').textContent = d.depRepos > 0 ? formatNumber(d.depRepos) + '+' : 'Н/Д';
  document.getElementById('detailMaintainers').textContent = d.maintainers;
  document.getElementById('detailBlast').textContent = d.blast;

  // CVEs
  const cveContainer = document.getElementById('detailCVEs');
  const cveSectionTitle = document.getElementById('cveSectionTitle');
  cveContainer.innerHTML = '';
  if (d.cves.length > 0) {
    cveSectionTitle.style.display = 'block';
    d.cves.forEach(cve => {
      const cvssColor = cve.cvss >= 9 ? '#ff1744' : cve.cvss >= 7 ? '#ff9100' : '#ffea00';
      cveContainer.innerHTML += `
        <div class="cve-item">
          <div class="cve-id">${cve.id}</div>
          <div class="cve-desc">${cve.desc}</div>
          <span class="cve-cvss" style="background:${hexToRGBA(cvssColor, 0.2)};color:${cvssColor};border:1px solid ${hexToRGBA(cvssColor, 0.3)}">CVSS ${cve.cvss}</span>
        </div>`;
    });
  } else {
    cveSectionTitle.style.display = 'none';
  }

  // Attacks
  const attackContainer = document.getElementById('detailAttacks');
  const attackSectionTitle = document.getElementById('attackSectionTitle');
  attackContainer.innerHTML = '';
  if (d.attacks.length > 0) {
    attackSectionTitle.style.display = 'block';
    d.attacks.forEach(a => {
      attackContainer.innerHTML += `
        <div class="attack-item">
          <span class="attack-date">${a.date}</span> — ${a.desc}
        </div>`;
    });
  } else {
    attackSectionTitle.style.display = 'none';
  }
}

// ══════════════════════════════════════════════════
// COMPROMISE SIMULATION
// ══════════════════════════════════════════════════
function toggleSimMode() {
  simMode = !simMode;
  const btn = document.getElementById('simBtn');
  const resetBtn = document.getElementById('simReset');
  const hint = document.getElementById('graphHint');

  if (simMode) {
    btn.classList.add('active');
    btn.innerHTML = '&#x26A0; РЕЖИМ СИМУЛЯЦИИ АКТИВЕН';
    resetBtn.style.display = 'inline-block';
    hint.textContent = 'Кликните узел для запуска каскадной симуляции';
    hint.style.color = '#ff1744';
  } else {
    resetSimulation();
  }
}

function resetSimulation() {
  simMode = false;
  const btn = document.getElementById('simBtn');
  const resetBtn = document.getElementById('simReset');
  const hint = document.getElementById('graphHint');

  btn.classList.remove('active');
  btn.innerHTML = '&#x26A0; Симуляция компрометации';
  resetBtn.style.display = 'none';
  hint.textContent = 'колёсико: масштаб · перетаскивание: навигация · клик: детали';
  hint.style.color = '#334';

  // Clear all compromise visuals
  nodeGroup.classed('compromised', false).classed('dimmed', false).classed('highlighted', false);
  linkGroup.classed('compromise-link', false).classed('dimmed', false);
  document.querySelectorAll('.link-arrow').forEach(el => el.classList.remove('compromise-arrow'));

  document.getElementById('compromise-panel').classList.remove('visible');
}

function runCompromiseSimulation(startNode) {
  // Reset previous
  nodeGroup.classed('compromised', false);
  linkGroup.classed('compromise-link', false);

  // BFS through reverse dependencies (who depends on compromised node)
  const visited = new Set();
  const queue = [{ id: startNode.id, depth: 0 }];
  visited.add(startNode.id);
  let maxDepth = 0;
  const depthMap = { [startNode.id]: 0 };

  while (queue.length > 0) {
    const { id, depth } = queue.shift();
    maxDepth = Math.max(maxDepth, depth);
    const dependents = adjReverse[id] || [];
    dependents.forEach(dep => {
      if (!visited.has(dep)) {
        visited.add(dep);
        depthMap[dep] = depth + 1;
        queue.push({ id: dep, depth: depth + 1 });
      }
    });
  }

  // Animate cascade with delay per depth level
  visited.forEach(nodeId => {
    const depth = depthMap[nodeId];
    setTimeout(() => {
      nodeGroup.filter(n => n.id === nodeId).classed('compromised', true);
    }, depth * 600);
  });

  // Highlight compromise edges
  linkGroup.each(function(e) {
    const sid = e.source.id || e.source;
    const tid = e.target.id || e.target;
    if (visited.has(sid) && visited.has(tid)) {
      const edgeDepth = Math.min(depthMap[sid] || 0, depthMap[tid] || 0);
      setTimeout(() => {
        d3.select(this).classed('compromise-link', true);
      }, edgeDepth * 600);
    }
  });

  // Calculate total downloads affected
  let totalDownloads = 0;
  visited.forEach(nodeId => {
    totalDownloads += (nodeMap[nodeId]?.downloads || 0);
  });

  // Show panel after animation completes
  setTimeout(() => {
    const panel = document.getElementById('compromise-panel');
    panel.classList.add('visible');
    document.getElementById('compNodes').textContent = visited.size;
    document.getElementById('compDownloads').textContent = formatNumber(totalDownloads) + '/мес';
    document.getElementById('compDepth').textContent = maxDepth;
  }, (maxDepth + 1) * 600);
}

// ══════════════════════════════════════════════════
// TIMELINE
// ══════════════════════════════════════════════════
function buildTimeline() {
  const track = document.getElementById('timelineTrack');
  const trackWidth = track.clientWidth || (window.innerWidth - 48);

  // Date range: 2022-10 to 2026-06
  const startDate = new Date(2022, 9);  // Oct 2022
  const endDate = new Date(2026, 5);    // Jun 2026
  const totalMs = endDate - startDate;

  // Year labels
  [2023, 2024, 2025, 2026].forEach(year => {
    const yearDate = new Date(year, 0);
    const pos = ((yearDate - startDate) / totalMs) * trackWidth;
    const label = document.createElement('div');
    label.className = 'timeline-year-label';
    label.style.left = pos + 'px';
    label.textContent = year;
    track.appendChild(label);
  });

  // Sort incidents by date for zigzag ordering
  const sorted = [...INCIDENTS].sort((a, b) => {
    const da = a.date.split('-'), db = b.date.split('-');
    return new Date(+da[0], +da[1] - 1) - new Date(+db[0], +db[1] - 1);
  });

  // Track positions to detect overlap and apply offset
  const usedPositions = [];

  sorted.forEach((inc, i) => {
    const parts = inc.date.split('-');
    const incDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1);
    let pos = ((incDate - startDate) / totalMs) * trackWidth;

    // If another incident occupies the same (or very close) position, shift right
    for (const used of usedPositions) {
      if (Math.abs(pos - used) < 70) {
        pos = used + 70;
      }
    }
    usedPositions.push(pos);

    // Zigzag: alternate between bottom row and top row
    const isUp = i % 2 === 1;

    const el = document.createElement('div');
    el.className = 'timeline-incident' + (isUp ? ' stagger-up' : '');
    el.style.left = (pos - 6) + 'px';
    el.style.bottom = isUp ? '40px' : '4px';
    el.title = inc.desc;

    // Connector line from dot to axis for stagger-up items
    const connectorHTML = isUp
      ? '<div class="timeline-connector" style="top: 12px; height: 28px;"></div>'
      : '';

    el.innerHTML = `
      <div class="timeline-dot"></div>
      ${connectorHTML}
      <div class="timeline-label">${inc.label}</div>
      <div class="timeline-date">${inc.date}</div>
    `;
    el.onclick = (e) => flashIncidentNodes(inc, e);
    track.appendChild(el);
  });
}

function flashIncidentNodes(incident, e) {
  // Remove previous active
  document.querySelectorAll('.timeline-incident.active').forEach(el => el.classList.remove('active'));
  e?.currentTarget?.classList.add('active');

  // Flash affected nodes
  incident.nodes.forEach(nodeId => {
    const nodeEl = nodeGroup.filter(n => n.id === nodeId);
    nodeEl.classed('incident-flash', false);
    // Force reflow
    nodeEl.each(function() { this.offsetWidth; });
    nodeEl.classed('incident-flash', true);
    setTimeout(() => nodeEl.classed('incident-flash', false), 1500);
  });

  // Show detail for first node
  const firstNode = NODES.find(n => n.id === incident.nodes[0]);
  if (firstNode) showNodeDetail(firstNode);
}

// Click on background → deselect
document.addEventListener('click', (e) => {
  if (e.target === document.getElementById('graphSvg') || e.target.tagName === 'svg') {
    document.getElementById('node-detail').classList.remove('visible');
  }
});
</script>
</body>
</html>
